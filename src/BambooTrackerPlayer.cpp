/* BambooTrackerPlayer - Godot GDExtension which plays .BTM files with YM2608 emulation
 * Copyright (c) 2024 Maxim Hoxha
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * The actual player node, make sure to only use one of these at any time, consider making this an autoload
 */

#include "BambooTrackerPlayer.h"
#include <godot_cpp/core/class_db.hpp>
#include <godot_cpp/variant/packed_vector2_array.hpp>
#include <godot_cpp/variant/vector2.hpp>
#include <vector>
#include <iostream>

using namespace godot;

void BambooTrackerPlayer::_bind_methods()
{
    ClassDB::bind_method(D_METHOD("getModule"), &BambooTrackerPlayer::getModule);
    ClassDB::bind_method(D_METHOD("setModule", "mod"), &BambooTrackerPlayer::setModule);
    ClassDB::add_property("BambooTrackerPlayer", PropertyInfo(Variant::OBJECT, "module", PropertyHint::PROPERTY_HINT_RESOURCE_TYPE, "BambooTrackerModule"), "setModule", "getModule");
    ClassDB::bind_method(D_METHOD("getSongNumber"), &BambooTrackerPlayer::getSongNumber);
    ClassDB::bind_method(D_METHOD("setSongNumber", "num"), &BambooTrackerPlayer::setSongNumber);
    ClassDB::add_property("BambooTrackerPlayer", PropertyInfo(Variant::INT, "currentSongNumber"), "setSongNumber", "getSongNumber");
    ClassDB::bind_method(D_METHOD("getOrderNumber"), &BambooTrackerPlayer::getOrderNumber);
    ClassDB::bind_method(D_METHOD("setOrderNumber", "num"), &BambooTrackerPlayer::setOrderNumber);
    ClassDB::add_property("BambooTrackerPlayer", PropertyInfo(Variant::INT, "currentOrderNumber"), "setOrderNumber", "getOrderNumber");
    ClassDB::bind_method(D_METHOD("getStepNumber"), &BambooTrackerPlayer::getStepNumber);
    ClassDB::bind_method(D_METHOD("setStepNumber", "num"), &BambooTrackerPlayer::setStepNumber);
    ClassDB::add_property("BambooTrackerPlayer", PropertyInfo(Variant::INT, "currentStepNumber"), "setStepNumber", "getStepNumber");
    ClassDB::bind_method(D_METHOD("PlayNewModule"), &BambooTrackerPlayer::PlayNewModule);
    ClassDB::bind_method(D_METHOD("PlaySong", "songNum", "forceRestart"), &BambooTrackerPlayer::PlaySong, DEFVAL(false));
    ClassDB::bind_method(D_METHOD("PlaySongFromName", "songName", "forceRestart"), &BambooTrackerPlayer::PlaySongFromName, DEFVAL(false));
    ClassDB::bind_method(D_METHOD("StopSong"), &BambooTrackerPlayer::StopSong);
    ClassDB::bind_method(D_METHOD("GetRegister", "addr"), &BambooTrackerPlayer::GetRegister);
    ClassDB::bind_method(D_METHOD("GetNote", "channel"), &BambooTrackerPlayer::GetNote);
}

BambooTrackerPlayer::BambooTrackerPlayer()
{
    //Create a nice audio stream so that we can push samples generated by our player for Godot to use
    outStream = Ref<AudioStreamGenerator>(new AudioStreamGenerator());
    outStream->set_mix_rate(55466);
    outStream->set_buffer_length(0.05);
    set_stream(outStream);
    //Set up YM2608 emulator
    isSongPlaying = false;
    chipController = std::make_shared<OPNAController>(chip::OpnaEmulator::Ymfm, 7987200, 55466, 2048, chip::ResamplerType::BlipBuf);
    instManager = std::make_shared<InstrumentsManager>(false);
    tickCounter = std::make_shared<TickCounter>();
    currentModule = std::make_shared<Module>();
    currentSongNum = -1;
    sampleBuffer = new int16_t[16384];
    outSampleBuffer = PackedVector2Array();
    outSampleBuffer.resize(4096);
    outSampleBuffer.fill(Vector2(0.0, 0.0));
    for (int i = 0; i < 19; i++)
    {
        currentNotes[i] = -1;
    }
}

BambooTrackerPlayer::~BambooTrackerPlayer()
{

}

int BambooTrackerPlayer::GetRetriggerMask(int curNote, int prevNote, int stepNote, int index)
{
    int retrigmask = 0;
    if (stepNote != Step::NoteValue::NOTE_NONE && stepNote != Step::NoteValue::NOTE_KEY_OFF && stepNote != Step::NoteValue::NOTE_KEY_CUT)
    {
        if (!retriggeredNotes[index])
        {
            if (curNote == prevNote) retrigmask = 0x80;
            retriggeredNotes[index] = true;
        }
    }
    return retrigmask;
}

void BambooTrackerPlayer::_process(double delta)
{
    if (!isSongPlaying) return;
    while (timeToNextTick <= 0.0)
    {
        double fltNumSamp = numSampRemainder + samplesPerTick;
        int64_t numSamples = (int64_t)(fltNumSamp);
        if (numSamples > playback->get_frames_available())
        {
            break;
        }
        numSampRemainder = fltNumSamp - (double)(numSamples);
        ticksToNextStep = pbManager->streamCountUp();
        if (pbManager->getPlayingOrderNumber() < 0 || pbManager->getPlayingStepNumber() < 0) ticksToNextStep = -1; //Hack
        if (ticksToNextStep == 0)
        {
            for (int i = 0; i < 19; i++)
            {
                retriggeredNotes[i] = false;
            }
        }
        else if (ticksToNextStep < 0)
        {
            orderNum = 0;
            stepNum = 0;
            for (int i = 0; i < 19; i++)
            {
                currentSteps[i] = 0;
                currentNotes[i] = -1;
                retriggeredNotes[i] = false;
            }

            isSongPlaying = false;
            currentSongNum = -1;
            stop();
            return;
        }
        bool success = chipController->getStreamSamples(sampleBuffer, numSamples);
        outSampleBuffer.resize(numSamples);
        for (int i = 0; i < numSamples; i++)
        {
            Vector2 samp = Vector2(sampleBuffer[i * 2], sampleBuffer[i * 2 + 1]);
            samp /= 32768.0;
            outSampleBuffer[i] = samp;
        }
        playback->push_buffer(outSampleBuffer);
        timeToNextTick += secondsPerTick;
        orderNum = pbManager->getPlayingOrderNumber();
        stepNum = pbManager->getPlayingStepNumber();
        if (chNum == 16)
        {
            for (int i = 0; i < 16; i++)
            {
                currentSteps[i] = &(currentSong->getTrack(i).getPatternFromOrderNumber(orderNum).getStep(stepNum));
            }
            for (int i = 0; i < 3; i++) //Copy FM3op4 into FM3op1-3
            {
                currentSteps[i+16] = currentSteps[2];
            }
        }
        else if (chNum == 19)
        {
            for (int i = 0; i < 2; i++) //FM1-2
            {
                currentSteps[i] = &(currentSong->getTrack(i).getPatternFromOrderNumber(orderNum).getStep(stepNum));
            }
            for (int i = 0; i < 3; i++) //FM3op1-3
            {
                currentSteps[i+16] = &(currentSong->getTrack(i+2).getPatternFromOrderNumber(orderNum).getStep(stepNum));
            }
            currentSteps[2] = &(currentSong->getTrack(5).getPatternFromOrderNumber(orderNum).getStep(stepNum)); //FM3op4
            for (int i = 0; i < 13; i++) //The rest of the channels
            {
                currentSteps[i+3] = &(currentSong->getTrack(i+6).getPatternFromOrderNumber(orderNum).getStep(stepNum));
            }
        }
    }
    timeToNextTick -= delta;
    if (chNum == 19)
    {
        for (int i = 0; i < 2; i++) //FM1-2
        {
            int outInd = i;
            int inInd = i;
            int retNote = chipController->getFMLatestNote(inInd).getNoteNumber();
            int stepNote = currentSteps[outInd]->getNoteNumber();
            int retrigmask = GetRetriggerMask(retNote, (currentNotes[outInd] & 0x7F), currentSteps[outInd]->getNoteNumber(), outInd);
            if (chipController->isKeyOnFM(inInd)) currentNotes[outInd] = retNote | retrigmask;
            else currentNotes[outInd] = -1;
        }
        for (int i = 0; i < 2; i++) //FM3op2-3
        {
            int outInd = i+17;
            int inInd = i+6;
            int retNote = chipController->getFMLatestNote(inInd).getNoteNumber();
            int stepNote = currentSteps[outInd]->getNoteNumber();
            int retrigmask = GetRetriggerMask(retNote, (currentNotes[outInd] & 0x7F), currentSteps[outInd]->getNoteNumber(), outInd);
            if (chipController->isKeyOnFM(inInd)) currentNotes[outInd] = retNote | retrigmask;
            else currentNotes[outInd] = -1;
        }
        { //FM3op1
            int outInd = 16;
            int inInd = 2;
            int retNote = chipController->getFMLatestNote(inInd).getNoteNumber();
            int stepNote = currentSteps[outInd]->getNoteNumber();
            int retrigmask = GetRetriggerMask(retNote, (currentNotes[outInd] & 0x7F), currentSteps[outInd]->getNoteNumber(), outInd);
            if (chipController->isKeyOnFM(inInd)) currentNotes[outInd] = retNote | retrigmask;
            else currentNotes[outInd] = -1;
        }
        { //FM3op4
            int outInd = 2;
            int inInd = 8;
            int retNote = chipController->getFMLatestNote(inInd).getNoteNumber();
            int stepNote = currentSteps[outInd]->getNoteNumber();
            int retrigmask = GetRetriggerMask(retNote, (currentNotes[outInd] & 0x7F), currentSteps[outInd]->getNoteNumber(), outInd);
            if (chipController->isKeyOnFM(inInd)) currentNotes[outInd] = retNote | retrigmask;
            else currentNotes[outInd] = -1;
        }
        for (int i = 0; i < 3; i++) //FM4-6
        {
            int outInd = i+3;
            int inInd = i+3;
            int retNote = chipController->getFMLatestNote(inInd).getNoteNumber();
            int stepNote = currentSteps[outInd]->getNoteNumber();
            int retrigmask = GetRetriggerMask(retNote, (currentNotes[outInd] & 0x7F), currentSteps[outInd]->getNoteNumber(), outInd);
            if (chipController->isKeyOnFM(inInd)) currentNotes[outInd] = retNote | retrigmask;
            else currentNotes[outInd] = -1;
        }
    }
    else if (chNum == 16)
    {
        for (int i = 0; i < 6; i++) //FM1-6
        {
            int outInd = i;
            int inInd = i;
            int retNote = chipController->getFMLatestNote(inInd).getNoteNumber();
            int stepNote = currentSteps[outInd]->getNoteNumber();
            int retrigmask = GetRetriggerMask(retNote, (currentNotes[outInd] & 0x7F), currentSteps[outInd]->getNoteNumber(), outInd);
            if (chipController->isKeyOnFM(inInd)) currentNotes[outInd] = retNote | retrigmask;
            else currentNotes[outInd] = -1;
        }
        for (int i = 0; i < 3; i++) //Copy FM3op4 into FM3op1-3
        {
            currentNotes[i+16] = currentNotes[2];
        }
    }
    for (int i = 0; i < 3; i++) //SSG1-3
    {
        int outInd = i+6;
        int inInd = i;
        int retNote = chipController->getSSGLatestNote(inInd).getNoteNumber();
        int stepNote = currentSteps[outInd]->getNoteNumber();
        int retrigmask = GetRetriggerMask(retNote, (currentNotes[outInd] & 0x7F), currentSteps[outInd]->getNoteNumber(), outInd);
        if (chipController->isKeyOnSSG(inInd)) currentNotes[outInd] = retNote | retrigmask;
        else currentNotes[outInd] = -1;
    }
    for (int i = 0; i < 6; i++) //Rhythm
    {
        int outInd = i+9;
        int inInd = i;
        int stepNote = currentSteps[outInd]->getNoteNumber();
        if (currentNotes[outInd] == -1)
        {
            if (stepNote != Step::NoteValue::NOTE_NONE && stepNote != Step::NoteValue::NOTE_KEY_OFF && stepNote != Step::NoteValue::NOTE_KEY_CUT) currentNotes[outInd] = 48; //Note doesn't matter for rhythm channels
            else currentNotes[outInd] = -1;
            retriggeredNotes[outInd] = false;
        }
        else
        {
            if (stepNote == Step::NoteValue::NOTE_KEY_OFF && stepNote == Step::NoteValue::NOTE_KEY_CUT) currentNotes[outInd] = -1;
            else if (stepNote == Step::NoteValue::NOTE_NONE)
            {
                currentNotes[outInd] = 48; //Note doesn't matter for rhythm channels
                retriggeredNotes[outInd] = false;
            }
            else if (!retriggeredNotes[outInd])
            {
                currentNotes[outInd] = 48 | 0x80;
                retriggeredNotes[outInd] = true;
            }
            else currentNotes[outInd] = 48; //Note doesn't matter for rhythm channels
        }
    }
    { //ADPCM
        int outInd = 15;
        int retNote = chipController->getADPCMLatestNote().getNoteNumber();
        int stepNote = currentSteps[outInd]->getNoteNumber();
        int retrigmask = GetRetriggerMask(retNote, (currentNotes[outInd] & 0x7F), currentSteps[outInd]->getNoteNumber(), outInd);
        if (chipController->isKeyOnADPCM()) currentNotes[outInd] = retNote | retrigmask;
        else currentNotes[outInd] = -1;
    }
}

void BambooTrackerPlayer::_ready()
{
    return;
}

void BambooTrackerPlayer::setModule(const Ref<BambooTrackerModule> &mod)
{
    module = mod;
}

Ref<BambooTrackerModule> BambooTrackerPlayer::getModule() const
{
    return module;
}

void BambooTrackerPlayer::setSongNumber(int64_t num)
{
    return; //You must set the song number with a method call
}

int64_t BambooTrackerPlayer::getSongNumber() const
{
    return currentSongNum;
}

void BambooTrackerPlayer::setOrderNumber(int64_t num)
{
    orderNum = num; //Not effective
}

int64_t BambooTrackerPlayer::getOrderNumber() const
{
    return orderNum;
}

void BambooTrackerPlayer::setStepNumber(int64_t num)
{
    stepNum = num; //Not effective
}

int64_t BambooTrackerPlayer::getStepNumber() const
{
    return stepNum;
}

void BambooTrackerPlayer::PlayNewModule()
{
    io::BinaryContainer container;
    std::vector<uint8_t> byteVector;
    PackedByteArray modDat = module->getModuleData();
    for (int i = 0; i < modDat.size(); i++)
    {
        byteVector.push_back(modDat[i]);
    }
    std::move(std::begin(byteVector), std::end(byteVector), std::back_inserter(container));
    io::ModuleIO::getInstance().loadModule(container, currentModule, instManager);
    tickCounter->setInterruptRate(currentModule->getTickFrequency());
    secondsPerTick = 1.0/((double)currentModule->getTickFrequency());
    samplesPerTick = 55466.0 * secondsPerTick;
    if (pbManager == NULL) pbManager = std::unique_ptr<PlaybackManager>(new PlaybackManager(chipController, instManager, tickCounter, currentModule, false));
    chipController->setMasterVolume(100);
    chipController->setMasterVolumeFM(currentModule->getCustomMixerFMLevel());
    chipController->setMasterVolumeSSG(currentModule->getCustomMixerSSGLevel());
    chipController->clearSamplesADPCM();
    std::vector<int> idcs = instManager->getSampleADPCMValidIndices();
    for (auto sampNum : idcs)
    {
        size_t startAddr, stopAddr;
        if (chipController->storeSampleADPCM(instManager->getSampleADPCMRawSample(sampNum), startAddr, stopAddr)) {
            instManager->setSampleADPCMStartAddress(sampNum, startAddr);
            instManager->setSampleADPCMStopAddress(sampNum, stopAddr);
        }
    }
}

void BambooTrackerPlayer::PlaySong(int64_t songNum, bool forceRestart)
{
    if (songNum < 0 || songNum >= module->getNumberOfSongs())
    {
        return; //Do not attempt to play an out-of-range song
    }
    if (!forceRestart && songNum == currentSongNum)
    {
        return; //Continue if the same song is reselected, unless the programmer wishes to force a restart
    }
    auto& song = currentModule->getSong(songNum);
    pbManager->setSong(currentModule, songNum);
    currentSongNum = songNum;
    chipController->reset();
    chipController->setMode(song.getStyle().type);
    tickCounter->resetCount();
    tickCounter->setTempo(song.getTempo());
    tickCounter->setSpeed(song.getSpeed());
    tickCounter->setGroove(currentModule->getGroove(song.getGroove()));
    tickCounter->setGrooveState(song.isUsedTempo() ? GrooveState::Invalid : GrooveState::ValidByGlobal);
    currentSong = &song;
    currentSongType = currentSong->getStyle().type;
    if (currentSongType == SongType::Standard) chNum = 16;
    else if (currentSongType == SongType::FM3chExpanded) chNum = 19;
    pbManager->startPlayFromStart();
    isSongPlaying = true;
    timeToNextTick = -0.05;
    numSampRemainder = 0.0;
    orderNum = 0;
    stepNum = 0;
    play();
    playback = get_stream_playback();
}

void BambooTrackerPlayer::PlaySongFromName(String songName, bool forceRestart)
{
    if (module->songNameMap.has(songName))
    {
        PlaySong(module->songNameMap[songName], forceRestart); //Only attempt to play a song if it actually exists in the module
    }
}

void BambooTrackerPlayer::StopSong()
{
    pbManager->stopPlaySong();

    orderNum = 0;
    stepNum = 0;
    for (int i = 0; i < 19; i++)
    {
        currentSteps[i] = 0;
        currentNotes[i] = -1;
        retriggeredNotes[i] = false;
    }

    isSongPlaying = false;
    currentSongNum = -1;
    stop();
}

int64_t BambooTrackerPlayer::GetRegister(int64_t addr)
{
    return chipController->getRegisterDebug((int)addr);
}

int64_t BambooTrackerPlayer::GetNote(int64_t channel)
{
    if (channel < 0 || channel > 18) return -1; //Out of range -> no note playing
    else return currentNotes[channel];
}
